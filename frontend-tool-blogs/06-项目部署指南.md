# 项目部署指南 - 从开发到生产的完整流程

## 前言

恭喜你完成了前端应用的开发！现在最重要的是将你的应用部署到生产环境，让用户能够访问。本文将详细介绍各种部署方式，从传统的服务器部署到现代的云原生部署，让你能够根据项目需求选择最合适的部署方案。

## 部署前的准备

### 环境配置文件
```javascript
// config/index.js
const config = {
    development: {
        env: 'development',
        port: 3000,
        database: {
            host: 'localhost',
            port: 27017,
            name: 'dev_db'
        },
        redis: {
            host: 'localhost',
            port: 6379
        },
        jwt: {
            secret: 'dev-secret-key'
        }
    },
    production: {
        env: 'production',
        port: process.env.PORT || 8080,
        database: {
            host: process.env.DB_HOST || 'localhost',
            port: process.env.DB_PORT || 27017,
            name: process.env.DB_NAME || 'prod_db'
        },
        redis: {
            host: process.env.REDIS_HOST || 'localhost',
            port: process.env.REDIS_PORT || 6379
        },
        jwt: {
            secret: process.env.JWT_SECRET || 'production-secret-key'
        }
    }
};

module.exports = config[process.env.NODE_ENV || 'development'];
```

### 环境变量模板
```bash
# .env.template
# 服务器配置
NODE_ENV=production
PORT=8080

# 数据库配置
DB_HOST=localhost
DB_PORT=27017
DB_NAME=your_db_name
DB_USER=your_db_user
DB_PASSWORD=your_db_password

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your_redis_password

# JWT配置
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=24h

# 日志配置
LOG_LEVEL=info
LOG_FILE_PATH=/var/log/app

# 文件上传配置
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# 邮件配置
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_email_password

# 第三方服务配置
SENTRY_DSN=your_sentry_dsn
NEW_RELIC_LICENSE_KEY=your_new_relic_key
```

### 生产环境优化
```javascript
// 生产环境中间件
const express = require('express');
const compression = require('compression');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');

const app = express();

// 安全头部
app.use(helmet());

// 压缩响应
app.use(compression());

// 请求限制
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100 // 限制每个IP 100次请求
});
app.use(limiter);

// 请求日志
app.use(morgan('combined'));

// 信任代理
app.set('trust proxy', 1);

// 静态文件缓存
app.use(express.static('public', {
    maxAge: '1y',
    etag: true
}));

// 错误处理
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
        message: '服务器内部错误',
        error: process.env.NODE_ENV === 'development' ? err.message : {}
    });
});
```

## 传统服务器部署

### 使用PM2部署
```bash
# 安装PM2
npm install -g pm2

# 启动应用
pm2 start app.js --name "my-app"

# 查看应用状态
pm2 status

# 查看日志
pm2 logs my-app

# 重启应用
pm2 restart my-app

# 停止应用
pm2 stop my-app

# 删除应用
pm2 delete my-app

# 保存PM2配置
pm2 save

# 设置开机自启
pm2 startup
```

### PM2配置文件
```javascript
// ecosystem.config.js
module.exports = {
    apps: [{
        name: 'my-app',
        script: 'app.js',
        instances: 'max',
        exec_mode: 'cluster',
        env: {
            NODE_ENV: 'development',
            PORT: 3000
        },
        env_production: {
            NODE_ENV: 'production',
            PORT: 8080
        },
        log_file: 'logs/combined.log',
        out_file: 'logs/out.log',
        error_file: 'logs/error.log',
        log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
        merge_logs: true,
        max_memory_restart: '1G',
        watch: false,
        max_restarts: 5,
        min_uptime: '10s',
        node_args: '--max-old-space-size=1024'
    }]
};
```

### Nginx配置
```nginx
# /etc/nginx/sites-available/my-app
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;

    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # SSL配置
    ssl_certificate /path/to/your/cert.pem;
    ssl_certificate_key /path/to/your/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # 静态文件
    location /static/ {
        alias /path/to/your/app/public/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # API代理
    location /api {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # 主应用
    location / {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;
}
```

## Docker部署

### Dockerfile配置
```dockerfile
# 多阶段构建
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产环境
FROM node:18-alpine AS runner

WORKDIR /app

# 创建用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# 复制生产依赖
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 复制构建文件
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/public ./public
COPY --from=builder /app/views ./views

# 复制必要文件
COPY app.js ./
COPY config ./

# 设置权限
RUN chown -R nodejs:nodejs /app

# 切换用户
USER nodejs

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 启动应用
CMD ["node", "app.js"]
```

### Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - DB_HOST=mongodb
      - REDIS_HOST=redis
    depends_on:
      - mongodb
      - redis
    restart: unless-stopped
    networks:
      - app-network

  mongodb:
    image: mongo:5
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    restart: unless-stopped
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass password
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    restart: unless-stopped
    networks:
      - app-network

volumes:
  mongodb_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

### Docker部署脚本
```bash
#!/bin/bash
# scripts/deploy-docker.sh

set -e

echo "🚀 开始Docker部署..."

# 构建镜像
echo "📦 构建Docker镜像..."
docker-compose build

# 停止现有容器
echo "🛑 停止现有容器..."
docker-compose down

# 启动新容器
echo "🚀 启动新容器..."
docker-compose up -d

# 等待服务启动
echo "⏳ 等待服务启动..."
sleep 30

# 健康检查
echo "🏥 执行健康检查..."
curl -f http://localhost:8080/health || {
    echo "❌ 健康检查失败"
    docker-compose logs
    exit 1
}

echo "✅ 部署完成！"
echo "🎉 应用已成功部署并运行"
```

## 云服务部署

### Heroku部署
```bash
# 安装Heroku CLI
npm install -g heroku

# 登录Heroku
heroku login

# 创建应用
heroku create your-app-name

# 添加构建包
heroku buildpacks:add heroku/nodejs

# 设置环境变量
heroku config:set NODE_ENV=production
heroku config:set JWT_SECRET=your-secret-key

# 部署代码
git push heroku main

# 查看日志
heroku logs --tail

# 打开应用
heroku open
```

### Heroku配置文件
```json
{
    "name": "my-app",
    "description": "My awesome application",
    "scripts": {
        "start": "node app.js",
        "test": "jest"
    },
    "engines": {
        "node": "18.x",
        "npm": "8.x"
    },
    "dependencies": {
        "express": "^4.18.2"
    },
    "devDependencies": {
        "jest": "^29.0.0"
    }
}
```

### AWS部署
```yaml
# aws.yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'Node.js Application Deployment'

Resources:
  ElasticBeanstalkApplication:
    Type: AWS::ElasticBeanstalk::Application
    Properties:
      Description: Node.js Application

  ElasticBeanstalkEnvironment:
    Type: AWS::ElasticBeanstalk::Environment
    Properties:
      ApplicationName: !Ref ElasticBeanstalkApplication
      SolutionStackName: "64bit Amazon Linux 2 v5.4.0 running Node.js 18"
      OptionSettings:
        - Namespace: aws:elasticbeanstalk:application:environment
          OptionName: NODE_ENV
          Value: production
        - Namespace: aws:elasticbeanstalk:application:environment
          OptionName: PORT
          Value: 8081
        - Namespace: aws:elasticbeanstalk:application:environment
          OptionName: JWT_SECRET
          Value: your-secret-key

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref InstanceRole

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: "*"
```

## CI/CD自动化部署

### GitHub Actions配置
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16, 18, 20]

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build application
        run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js 18
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Deploy to production
        run: |
          # 部署逻辑
          echo "🚀 开始部署..."
          # 添加你的部署脚本
          # 例如：rsync、scp、docker等

      - name: Health check
        run: |
          # 部署后健康检查
          sleep 30
          curl -f https://your-domain.com/health || exit 1
```

### Jenkins配置
```groovy
// Jenkinsfile
pipeline {
    agent any
    environment {
        NODE_ENV = 'production'
        DEPLOY_PATH = '/var/www/my-app'
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/your-username/your-repo.git'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }

        stage('Run Tests') {
            steps {
                sh 'npm test'
            }
        }

        stage('Build') {
            steps {
                sh 'npm run build'
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                    # 停止现有服务
                    pm2 stop my-app || true

                    # 备份现有文件
                    cp -r $DEPLOY_PATH $DEPLOY_PATH.backup

                    # 复制新文件
                    rsync -av --delete dist/ $DEPLOY_PATH/

                    # 安装生产依赖
                    cd $DEPLOY_PATH
                    npm ci --only=production

                    # 启动服务
                    pm2 start app.js --name "my-app"

                    # 健康检查
                    sleep 10
                    curl -f http://localhost:8080/health || exit 1
                '''
            }
        }
    }

    post {
        success {
            echo '🎉 部署成功！'
        }
        failure {
            echo '❌ 部署失败！'
            # 回滚操作
            sh '''
                if [ -d "$DEPLOY_PATH.backup" ]; then
                    cp -r $DEPLOY_PATH.backup/* $DEPLOY_PATH/
                    pm2 restart my-app
                fi
            '''
        }
    }
}
```

## 监控和日志

### 健康检查端点
```javascript
// app.js
app.get('/health', (req, res) => {
    const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        environment: process.env.NODE_ENV
    };

    // 检查数据库连接
    if (mongoose.connection.readyState === 1) {
        health.database = 'connected';
    } else {
        health.database = 'disconnected';
    }

    // 检查Redis连接
    if (redisClient.status === 'ready') {
        health.redis = 'connected';
    } else {
        health.redis = 'disconnected';
    }

    const statusCode = health.database === 'connected' && health.redis === 'connected' ? 200 : 503;
    res.status(statusCode).json(health);
});
```

### 日志收集配置
```javascript
// winston.js
const winston = require('winston');
const { combine, timestamp, printf, colorize, errors } = winston.format;

const logFormat = printf(({ level, message, timestamp, stack }) => {
    return `${timestamp} [${level}]: ${stack || message}`;
});

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: combine(
        errors({ stack: true }),
        timestamp(),
        logFormat
    ),
    transports: [
        new winston.transports.Console({
            format: combine(
                colorize(),
                errors({ stack: true }),
                timestamp(),
                logFormat
            )
        }),
        new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error'
        }),
        new winston.transports.File({
            filename: 'logs/combined.log'
        })
    ]
});

module.exports = logger;
```

### 性能监控
```javascript
// performance.js
const newrelic = require('newrelic');
const promClient = require('prom-client');

// 创建指标收集器
const httpRequestDurationMicroseconds = new promClient.Histogram({
    name: 'http_request_duration_ms',
    help: 'Duration of HTTP requests in ms',
    labelNames: ['method', 'route', 'code'],
    buckets: [50, 100, 200, 300, 400, 500, 1000]
});

const httpRequestsTotal = new promClient.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'code']
});

// 中间件
app.use((req, res, next) => {
    const end = httpRequestDurationMicroseconds.startTimer();
    res.on('finish', () => {
        const route = req.route ? req.route.path : 'unknown';
        httpRequestDurationMicroseconds.end({
            route: route,
            method: req.method,
            code: res.statusCode
        });
        httpRequestsTotal.inc({
            route: route,
            method: req.method,
            code: res.statusCode
        });
    });
    next();
});

// 指标端点
app.get('/metrics', (req, res) => {
    res.set('Content-Type', promClient.register.contentType);
    res.end(promClient.register.metrics());
});
```

## 回滚策略

### 备份脚本
```bash
#!/bin/bash
# scripts/backup.sh

BACKUP_DIR="/backup/my-app"
APP_DIR="/var/www/my-app"
DATE=$(date +%Y%m%d_%H%M%S)

echo "🔄 开始备份..."

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份应用文件
tar -czf $BACKUP_DIR/app_$DATE.tar.gz -C $APP_DIR .

# 备份数据库
mongodump --host localhost --port 27017 --db myapp --out $BACKUP_DIR/mongo_$DATE

# 备份日志
cp -r /var/log/my-app $BACKUP_DIR/logs_$DATE

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete
find $BACKUP_DIR -name "mongo_*" -mtime +7 -delete
find $BACKUP_DIR -name "logs_*" -mtime +7 -delete

echo "✅ 备份完成: $BACKUP_DIR/app_$DATE.tar.gz"
```

### 回滚脚本
```bash
#!/bin/bash
# scripts/rollback.sh

BACKUP_DIR="/backup/my-app"
APP_DIR="/var/www/my-app"

echo "🔄 开始回滚..."

# 查找最新备份
LATEST_BACKUP=$(ls -t $BACKUP_DIR/app_*.tar.gz | head -1)

if [ -z "$LATEST_BACKUP" ]; then
    echo "❌ 未找到备份文件"
    exit 1
fi

echo "📦 使用备份: $LATEST_BACKUP"

# 停止服务
pm2 stop my-app

# 备份当前版本
cp -r $APP_DIR $APP_DIR.failed

# 恢复文件
tar -xzf $LATEST_BACKUP -C $APP_DIR --strip-components=1

# 恢复数据库
LATEST_MONGO=$(ls -t $BACKUP_DIR/mongo_* | head -1)
if [ -n "$LATEST_MONGO" ]; then
    mongorestore --host localhost --port 27017 --db myapp --drop $LATEST_MONGO/myapp
fi

# 启动服务
pm2 start my-app

# 健康检查
sleep 10
curl -f http://localhost:8080/health || {
    echo "❌ 回滚后健康检查失败"
    pm2 logs my-app
    exit 1
}

echo "✅ 回滚完成！"
```

## 安全配置

### 防火墙配置
```bash
# Ubuntu UFW配置
sudo ufw allow 22/tcp      # SSH
sudo ufw allow 80/tcp      # HTTP
sudo ufw allow 443/tcp     # HTTPS
sudo ufw enable
```

### SSL证书配置
```bash
# 安装Certbot
sudo apt install certbot python3-certbot-nginx

# 获取SSL证书
sudo certbot --nginx -d your-domain.com -d www.your-domain.com

# 自动续期
sudo crontab -e
# 添加：0 12 * * * /usr/bin/certbot renew --quiet
```

## 部署检查清单

```markdown
## 部署前检查清单

- [ ] 代码已合并到主分支
- [ ] 所有测试通过
- [ ] 代码审查完成
- [ ] 环境变量已设置
- [ ] 数据库已备份
- [ ] SSL证书已配置
- [ ] 监控系统已配置
- [ ] 日志系统已配置
- [ ] 回滚策略已准备

## 部署后检查清单

- [ ] 应用成功启动
- [ ] 健康检查通过
- [ ] 数据库连接正常
- [ ] 缓存服务正常
- [ ] 第三方服务连接正常
- [ ] 日志正常输出
- [ ] 监控指标正常
- [ ] 性能测试通过
- [ ] 安全测试通过
```

## 常见问题解答

### Q: 部署后出现502错误怎么办？
A: 检查应用是否正常运行、端口是否正确、防火墙设置、代理配置。

### Q: 如何处理数据库迁移？
A: 编写迁移脚本，在部署前备份数据库，部署后执行迁移，失败时回滚。

### Q: 如何监控生产环境？
A: 使用APM工具（New Relic、Datadog）、日志收集（ELK Stack）、监控告警（Prometheus + Grafana）。

## 总结

通过本文的学习，你已经掌握了：

1. 生产环境配置和优化
2. 传统的服务器部署
3. Docker容器化部署
4. 云服务部署方案
5. CI/CD自动化部署
6. 监控和日志系统
7. 回滚策略
8. 安全配置

部署是软件开发的最后一步，但也是至关重要的一步。一个完善的部署流程能够确保你的应用稳定、安全地运行在生产环境中。

恭喜你完成了整个前端工具学习系列！现在你已经具备了从前端开发到部署的完整技能，可以独立构建和部署现代化的Web应用了。

---

**扩展阅读：**
- [Docker官方文档](https://docs.docker.com/)
- [Kubernetes文档](https://kubernetes.io/docs/)
- [DevOps最佳实践](https://www.devops.com/)
- [CI/CD最佳实践](https://docs.github.com/en/actions)

**练习项目：**
1. 将治愈系图片系统部署到云服务器
2. 搭建完整的CI/CD流程
3. 实现自动化监控和告警系统